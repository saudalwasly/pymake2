#! /usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
import time

__author__ = 'Saud Wasly'

Debug = False
HighlightErrors = False
HighlightWarnings = False
Debug = True
extra_args = []

import argparse
import re
try:
  pass
  import argcomplete
except ImportError:
  print 'Warning: Autocomplete is not working\nYou need to install argcomplete package'

import os
import sys
import glob
import types
import inspect

try:
  import utility as util
  import make
  from make import Make_t
  from makefile_template import gccTemplate
except:
  from pymake2 import utility as util
  from pymake2 import make
  from make import Make_t
  from pymake2.makefile_template import gccTemplate
  
fd_out = None # used to bash auto complete only

class argsT():
  t = 'all'
  f = None
  j = 1
    
def getTargets_forBash_autocomplete(makefile_path=''):
  Targets = []
  if makefile_path == '':
    makefile_path = './makefile.py'
  if os.path.isfile(makefile_path):
    f = open(makefile_path,'rb')
    makefile_str = f.read()
    f.close()
    makefile_lines = makefile_str.splitlines()
    for i,l in enumerate(makefile_lines):
      if l.startswith('@target'):
        resV = re.findall(r'def\s+(\w+)\s*\(', makefile_lines[i+1])
        Targets.append(resV[0])
  return Targets

def complete_targets(prefix, parsed_args, **kwargs):
  Targets = []
  # argcomplete.warn(parsed_args)
  # argcomplete.warn(parsed_args.f)
  if  parsed_args.f:
    Targets = getTargets_forBash_autocomplete(parsed_args.f)
  elif os.path.isfile('./makefile.py'):
    Targets = getTargets_forBash_autocomplete('./makefile.py')
  else:
    Targets = ["No_MakeFile"]
  
  return Targets
  # return ['ali', 'saud', 'xxx']

def print_cmd2():
  argcomplete.warn('print_cmd2:')
  argcomplete.warn('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
  argcomplete.warn('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
  argcomplete.warn('COMP_LINE: ', os.environ['COMP_LINE'])
  argcomplete.warn('COMP_POINT: ', os.environ['COMP_POINT'])
  argcomplete.warn('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
  argcomplete.warn('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])

def print2cmd(txt):
  fd_out.write(txt)


def print_cmd():
  fout = os.fdopen(8, "wb")
  
  def printl(l1, l2=''):
    fout.write('%s,%s\n\n'%(l1,l2))
  try:
    printl('Envirnoment')
    # printl('_ARGCOMPLETE: ', os.environ['_ARGCOMPLETE'])
    # printl('_ARGCOMPLETE_IFS: ', os.environ['_ARGCOMPLETE_IFS'])
    # printl('COMP_LINE: ', os.environ['COMP_LINE'])
    # printl('COMP_POINT: ', os.environ['COMP_POINT'])
    # printl('_ARGCOMPLETE_COMP_WORDBREAKS: ', os.environ['_ARGCOMPLETE_COMP_WORDBREAKS'])
    # printl('COMP_WORDBREAKS: ', os.environ['COMP_WORDBREAKS'])
  except:
    pass

  fout.close()

def pymake2(MakefilePath, target):
  makefileM = imp.load_source('makefileM', MakefilePath)
  # todo: should 'Debug', 'HighlightErrors' and 'HighlightErrors' be checked only on top-level makefile or all makefiles? 
  Debug = getattr(makefileM, 'Debug', False)
  HighlightErrors = getattr(makefileM, 'HighlightErrors', False)
  HighlightWarnings = getattr(makefileM, 'HighlightWarnings', False)
  Targets = Parse_Makefile(MakefilePath, makefileM) #type: dict[str, Target_t]
  
  try:
    selected_Target = Targets[target.strip()]
  except:
    util.print_color('Error: target function "%s" does not exist!' % target, util.tty_colors_cmds.BRed)
    if Debug:
      traceback.print_exc()
    sys.exit()
   
  retV = selected_Target.run()
  return retV

def main():
  global Debug, HighlightErrors, HighlightWarnings, extra_args
  parser = argparse.ArgumentParser(description='pymake2 is a simple make system implemented in python')
  parser.add_argument('-h+', '--help+', action='store_true', help='help for callable functions in makefiles, short version')
  parser.add_argument('-h++', '--help++', action='store_true', help='help for callable functions in makefiles, long version')
  parser.add_argument('t', metavar='Target', help='the make target in the makefile').completer = complete_targets
  parser.add_argument('-f', metavar='MakefilePath', help='to pass a makefile, default = ./makefile.py')
  parser.add_argument('-j', metavar='Jobs', type=int, help='number of jobs used in the make process')
  
  print sys.argv
  if '-h+' in sys.argv or '-h++' in sys.argv:
    print "Help for callable functions in makefile when importing pymake2:"
    for obj in inspect.getmembers(make):
      func = obj[1]
      if hasattr(func, 'is_callable_by_makefile'):
        if '-h+' in sys.argv:
          print "   %s(%s)" %(func.__name__, ', '.join(inspect.getargspec(func)[0]))
        else:
          print "%s(%s): %s" %(func.__name__, ', '.join(inspect.getargspec(func)[0]), func.__doc__)
    os._exit(0)

  argcomplete.autocomplete(parser)
  if len(sys.argv) >1:
    args, extra_args = parser.parse_known_args()
  else:
    args = argsT()
  
  if args.f:
    MakefilePath = args.f
  elif os.path.isfile('./makefile.py'):
    MakefilePath = './makefile.py'
  else:
     retV = raw_input('No makefile exists!, do you want to creat one?(y/n): ')
     if retV.lower() == 'y':
        F = open('makefile.py', 'wb')
        F.write(gccTemplate)
        F.close()     
     sys.exit()
  
  pkgdir = os.path.normpath(os.path.dirname(__file__) + '/../')
  sys.path.insert(0, pkgdir)
  if os.path.exists('/opt/pymake2'):
    sys.path.insert(0, '/opt/')
    
  #make.shell('rm -f *.pyc')
  for pycFile in glob.glob('*.pyc'):
    try:
      os.remove(pycFile)
    except OSError:
      util.print_color('Error: cannot delete file "%s".' % pycFile, util.tty_colors_cmds.BRed)
  my_make = Make_t(MakefilePath, args.t, extra_args)
  # print 'Done !'
  
if __name__ == '__main__':
  main()
